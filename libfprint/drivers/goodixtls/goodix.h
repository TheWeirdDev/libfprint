/*
 * Goodix 5110 driver for libfprint
 *
 * Copyright (C) 2021 Alexander Meiler <alex.meiler@protonmail.com>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 */

#pragma once

#include <glib.h>
#include <stdint.h>
#include <openssl/ssl.h>
#include <openssl/err.h>

#define GOODIX_VEND_ID 0x27c6

#define GOODIX_CMD_LEN 64
#define GOODIX_EP_CMD_OUT 0x1
#define GOODIX_EP_CMD_IN 0x81

// Needed for commands which don't send an answer back (currently known only NOP)
#define GOODIX_CMD_SKIP_READ -1

// 10 seconds USB read timeout
#define GOODIX_CMD_TIMEOUT 10000

#define GOODIX_FIRMWARE_VERSION_SUPPORTED "GF_ST411SEC_APP_12109"

#define GOODIX_ACK_LEN 10

#define GOODIX_PSK_LEN 32

char zero_PSK_hash[] = {0xba, 0x1a, 0x86, 0x03, 0x7c, 0x1d, 0x3c, 0x71, 0xc3, 0xaf, 0x34, 0x49, 0x55, 0xbd, 0x69, 0xa9, 0xa9, 0x86, 0x1d, 0x9e, 0x91, 0x1f, 0xa2, 0x49, 0x85, 0xb6, 0x77, 0xe8, 0xdb, 0xd7, 0x2d, 0x43};

struct goodix_cmd
{
  uint8_t cmd[GOODIX_CMD_LEN];
  uint8_t cmd_cfg[GOODIX_CMD_LEN * 5];
  int response_len;
  int response_len_2;
};

static const struct goodix_cmd nop = {
  .cmd = {0xA0, 0x08, 0x00, 0xA8, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA5},
  .response_len = GOODIX_CMD_SKIP_READ,
};

static const struct goodix_cmd enable_chip = {
  .cmd = {0xA0, 0X06, 0x00, 0xA6, 0x96, 0x03, 0x00, 0x01, 0x00, 0x10},
  .response_len = GOODIX_ACK_LEN,
};

static const struct goodix_cmd read_fw = {
  .cmd = {0xA0, 0x06, 0x00, 0xA6, 0xA8, 0x03, 0x00, 0x00, 0x00, 0xFF},
  .response_len = GOODIX_ACK_LEN,
  .response_len_2 = 30,
};

static const struct goodix_cmd read_psk = {
  .cmd = {0xA0, 0x0C, 0x00, 0xAC, 0xE4, 0x09, 0x00, 0x03, 0x00, 0x02, 0xBB, 0x00, 0x00, 0x00, 0x00, 0xFD},
  .response_len = GOODIX_ACK_LEN,
  .response_len_2 = 49,
};

static const struct goodix_cmd mcu_set_idle = {
  .cmd = {0xA0, 0x06, 0x00, 0xA6, 0x70, 0x03, 0x00, 0x14, 0x00, 0x23},
  .response_len = GOODIX_ACK_LEN,
};

static const struct goodix_cmd mcu_set_config = {
  .cmd = {0xDE, 0xAD, 0xB3, 0x3F},
  .cmd_cfg = {
    0xA0, 0x04, 0x01, 0xA5, 0x90, 0x01, 0x01, 0x70, 0x11, 0x60, 0x71, 0x2c, 0x9d, 0x2c, 0xc9,
    0x1c, 0xe5, 0x18, 0xfd, 0x00, 0xfd, 0x00, 0xfd, 0x03, 0xba, 0x00, 0x01, 0x80, 0xca, 0x00,
    0x04, 0x00, 0x84, 0x00, 0x15, 0xb3, 0x86, 0x00, 0x00, 0xc4, 0x88, 0x00, 0x00, 0xba, 0x8a,
    0x00, 0x00, 0xb2, 0x8c, 0x00, 0x00, 0xaa, 0x8e, 0x00, 0x00, 0xc1, 0x90, 0x00, 0xbb, 0xbb,
    0x92, 0x00, 0xb1, 0xb1, 0x94, 0x00, 0x00, 0xa8, 0x96, 0x00, 0x00, 0xb6, 0x98, 0x00, 0x00,
    0x00, 0x9a, 0x00, 0x00, 0x00, 0xd2, 0x00, 0x00, 0x00, 0xd4, 0x00, 0x00, 0x00, 0xd6, 0x00,
    0x00, 0x00, 0xd8, 0x00, 0x00, 0x00, 0x50, 0x00, 0x01, 0x05, 0xd0, 0x00, 0x00, 0x00, 0x70,
    0x00, 0x00, 0x00, 0x72, 0x00, 0x78, 0x56, 0x74, 0x00, 0x34, 0x12, 0x20, 0x00, 0x10, 0x40,
    0x2a, 0x01, 0x02, 0x04, 0x22, 0x00, 0x01, 0x20, 0x24, 0x00, 0x32, 0x00, 0x80, 0x00, 0x01,
    0x00, 0x5c, 0x00, 0x80, 0x00, 0x56, 0x00, 0x04, 0x20, 0x58, 0x00, 0x03, 0x02, 0x32, 0x00,
    0x0c, 0x02, 0x66, 0x00, 0x03, 0x00, 0x7c, 0x00, 0x00, 0x58, 0x82, 0x00, 0x80, 0x15, 0x2a,
    0x01, 0x82, 0x03, 0x22, 0x00, 0x01, 0x20, 0x24, 0x00, 0x14, 0x00, 0x80, 0x00, 0x01, 0x00,
    0x5c, 0x00, 0x00, 0x01, 0x56, 0x00, 0x04, 0x20, 0x58, 0x00, 0x03, 0x02, 0x32, 0x00, 0x0c,
    0x02, 0x66, 0x00, 0x03, 0x00, 0x7c, 0x00, 0x00, 0x58, 0x82, 0x00, 0x80, 0x1f, 0x2a, 0x01,
    0x08, 0x00, 0x5c, 0x00, 0x80, 0x00, 0x54, 0x00, 0x10, 0x01, 0x62, 0x00, 0x04, 0x03, 0x64,
    0x00, 0x19, 0x00, 0x66, 0x00, 0x03, 0x00, 0x7c, 0x00, 0x01, 0x58, 0x2a, 0x01, 0x08, 0x00,
    0x5c, 0x00, 0x00, 0x01, 0x52, 0x00, 0x08, 0x00, 0x54, 0x00, 0x00, 0x01, 0x66, 0x00, 0x03,
    0x00, 0x7c, 0x00, 0x01, 0x58, 0x00, 0x89, 0x2e, 0x6f
  },
  .response_len = GOODIX_ACK_LEN,
  .response_len_2 = 10,
};

static const struct goodix_cmd set_powerdown_scan_frequency = {
  .cmd = {0xA0, 0x06, 0x00, 0xA6, 0x94, 0x03, 0x00, 0x64, 0x00, 0xAF},
  .response_len = GOODIX_ACK_LEN,
  .response_len_2 = 10,
};

G_DECLARE_FINAL_TYPE (FpiDeviceGoodixTLS, fpi_device_goodixtls, FPI, DEVICE_GOODIXTLS,
                      FpImageDevice);

// VID=0 PID=0 is needed for termination
static const FpIdEntry goodix_id_table[] = {
  {.vid = GOODIX_VEND_ID,  .pid = 0x5110, .driver_data = 0},
  {.vid = 0,  .pid = 0,  .driver_data = 0},
};

static void goodix_dev_reset_state (FpiDeviceGoodixTLS *goodixdev);
static void goodix_cmd_cb (FpiUsbTransfer *transfer, FpDevice *dev, gpointer user_data, GError *error);
